/*#define LSBFIRST 0
#define MSBFIRST 1

#define max7219_reg_noop 0x00
#define max7219_reg_digit0 0x01
#define max7219_reg_digit1 0x02
#define max7219_reg_digit2 0x03
#define max7219_reg_digit3 0x04
#define max7219_reg_digit4 0x05
#define max7219_reg_digit5 0x06
#define max7219_reg_digit6 0x07
#define max7219_reg_digit7 0x08
#define max7219_reg_decodeMode 0x09
#define max7219_reg_intensity 0x0a
#define max7219_reg_scanLimit 0x0b
#define max7219_reg_shutdown 0x0c
#define max7219_reg_displayTest 0x0f

#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
#define bitSet(value, bit) ((value) |= (1UL << (bit)))
#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))

const uint8_t mawL[] =    {32, 8,
                        0b00000000, 0b00000000, 0b00000000, 0b00000111, 0b00011111, 0b01111000, 0b11100000, 0b10000000,
                        0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11100000, 0b01111000, 0b00011110, 0b00000111,
                        0b00000000, 0b00000000, 0b00000000, 0b00000001, 0b00000111, 0b00011110, 0b01111000, 0b11100000,
                        0b00000100, 0b00011110, 0b01111011, 0b11100011, 0b11111111, 0b00000000, 0b00000000, 0b00000000
                       };

DigitalOut data(A2);
DigitalOut load(A1);
DigitalOut clk(A0);


uint8_t num = 4;
uint8_t buffer[112];


void shiftOut(DigitalOut dataPin, DigitalOut clockPin, uint8_t bitOrder, uint8_t val)
{
     uint8_t i;

    for (i = 0; i < 8; i++)  {
        if (bitOrder == LSBFIRST)
            dataPin.write(!!(val & (1 << i)));
        else    
            dataPin.write(!!(val & (1 << (7 - i))));

        clockPin.write(1);
        clockPin.write(0);       
    }
}

void setDot(uint8_t col, uint8_t row, uint8_t value)
{
    bitWrite(buffer[col], row, value);

	int n = col / 8;
	int c = col % 8;
	load.write(0) ; 
	for (int i=0; i<num; i++) 
	{
		if (i == n)
		{
			shiftOut(data, clk, MSBFIRST, c + 1);
			shiftOut(data, clk, MSBFIRST, buffer[col]);
		}
		else
		{
			shiftOut(data, clk, MSBFIRST, 0);
			shiftOut(data, clk, MSBFIRST, 0);
		}
	}
	load.write(0);
	load.write(1);  
}

void setColumn(uint8_t col, uint8_t value)
{
	int n = col / 8;
	int c = col % 8;
	load.write(0);  
	for (int i=0; i<num; i++) 
	{
		if (i == n)
		{
			shiftOut(data, clk, MSBFIRST, c + 1);
			shiftOut(data, clk, MSBFIRST, value);
		}
		else
		{
			shiftOut(data, clk, MSBFIRST, 0);
			shiftOut(data, clk, MSBFIRST, 0);
		}
	}
	load.write(0);  
	load.write(1);  
	
	buffer[col] = value;
}

void setColumnAll(uint8_t col, uint8_t value)
{
	load.write(0);      
	for (int i=0; i<num; i++) 
	{
		shiftOut(data, clk, MSBFIRST, col + 1);
		shiftOut(data, clk, MSBFIRST, value);
		buffer[col * i] = value;
	}
	load.write(0);  
	load.write(1);  
}

void writeSprite(int x, int y, const uint8_t* sprite)
{
	int w = sprite[0];
	int h = sprite[1];
	
	if (h == 8 && y == 0)
		for (int i=0; i<w; i++)
		{
			int c = x + i;
			if (c>=0 && c<112)
				setColumn(c, sprite[i+2]);
		}
	else
		for (int i=0; i<w; i++)
			for (int j=0; j<h; j++)
			{
				int c = x + i;
				int r = y + j;
				if (c>=0 && c<112 && r>=0 && r<8)
					setDot(c, r, bitRead(sprite[i+2], j));
			}
}

void reload()
{
	for (int i=0; i<8; i++)
	{
		int col = i;
		load.write(0);  
		for (int j=0; j<num; j++) 
		{
			shiftOut(data, clk, MSBFIRST, i + 1);
			shiftOut(data, clk, MSBFIRST, buffer[col]);
			col += 8;
		}
		load.write(0);  
		load.write(1);
	}
}


void setCommand(uint8_t command, uint8_t value)
{
	load.write(0);   
	for (int i=0; i<num; i++) 
	{
		shiftOut(data, clk, MSBFIRST, command);
		shiftOut(data, clk, MSBFIRST, value);
	}
	load.write(0);   
	load.write(1);
}


void clear()
{
	for (int i=0; i<8; i++) 
		setColumnAll(i,0);
		
	for (int i=0; i<112; i++)
		buffer[i] = 0;
}

void setIntensity(uint8_t intensity)
{
	setCommand(max7219_reg_intensity, intensity);
}

void init()
{
	
	clk = 1;

	setCommand(max7219_reg_scanLimit, 0x07);      
	setCommand(max7219_reg_decodeMode, 0x00);  // using an led matrix (not digits)
	setCommand(max7219_reg_shutdown, 0x01);    // not in shutdown mode
	setCommand(max7219_reg_displayTest, 0x00); // no display test
	
	// empty registers, turn all LEDs off
	clear();
	
	setIntensity(0x0f);    // the first 0x0f is the value you can set
}
*/